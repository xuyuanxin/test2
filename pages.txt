
http://www.valleytalk.org/wp-content/uploads/2015/04/System-Issues-for-High-End-Security-Appliance-Design.pdf

http://www.ibm.com/developerworks/cn/linux/l-makefile/
http://www.oschina.net/question/54100_32476
http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html 
http://tldp.org/HOWTO/pdf/Unix-and-Internet-Fundamentals-HOWTO.pdf

Scitools Understand

-------------------------------------------------------------------------------------|
http://www.cnblogs.com/zhuyp1015/archive/2012/05/06/2486650.html                     |
可执行文件的装载                                                                     |
----> 程序和进程                                                                     |
程序是一个静态的概念, 它就是这些预编译好的指令和数据集合的一个文件; 进程则是一个动态 |
的概念, 它是程序运行时的一个过程, 很多时候把动态库叫做运行时也有一定的含义.          |
一般来来说, C语言指针大小的位数与虚拟空间的位数相同, 如果32位平台下指针为32位, 即4字 |
节; 64位平台下的指针为64位, 即8字节. Intel自从1995年的Pentium Pro CPU开始采用了36位的|
物理地址, 也就是可以访问高达64GB的物理内存. Intel把这个地址扩展方式叫做PAE（Physical |
Address Extension).                                                                  |
----> 装载方式                                                                       |
覆盖装入和页映射是两种很典型的动态装载方法, 它们都利用了程序的局部性原理.            |
----> 操作系统角度下的文件装载                                                       |
从操作系统的角度, 一个进程最关键的特征是它拥有独立的虚拟地址空间, 这使得它有别于其他 |
进程. 一个程序被执行同时都伴随着一个新进程的创建:创建一个进程, 然后装载相应的可执行文|
件并且执行. 该工程需要做三件事:                                                      |
*创建一个独立的虚拟地址空间                                                          |
将虚拟空间的各个页映射至相应的物理空间, 实际上只是分配了一个页目录(Page Directory)就 |
可以了.                                                                              |
*读取可执行文件头, 并且建立虚拟空间与可执行文件的映射关系                            |
建立虚拟地址空间与可执行文件的映射关系. 当发生缺页故障时, 操作系统应该知道当前所需要 |
的页在可执行文件中的哪个位置, 这就是虚拟空间与可执行文件之间的映射关系. 这种映射关系 |
只是保存在操作系统内部的一个数据构. Linux中将进程虚拟空间中的一个段叫做虚拟内存区域( |
VMA, Virtual Memory Area); 在Windows中将这个叫做虚拟段(Virtual Section).             |
*将CPU的指令寄存器设置成可执行文件的入口地址, 启动并运行                             |
----> 进程虚拟空间分布                                                               |
ELF文件中, 段的权限只有为数不多的几种组合:                                           |
*以代码段为代表的权限为可读可执行的段                                                |
*以数据段和BSS段为代表的权限为可读可写的段                                           |
*以只读数据段为代表的权限为只读的段.                                                 |
对于相同权限的段, 把它们合并到一起当做一个段进行映射.                                |
~~~~~~~~~~~~~~~~~~~~~~~~~ a.c beg                                                    |
#include <stdlib.h>

int main()
{
  while(1) sleep(1000);
  return 0;
}
~~~~~~~~~~~~~~~~~~~~~~~~~a.c end                                                     |
#gcc -static -o SectionMapping.elf a.c
#readelf -S SectionMapping.elf

There are 29 section headers, starting at offset 0x868dc:
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .note.ABI-tag     NOTE            080480f4 0000f4 000020 00   A  0   0  4
  [ 2] .note.gnu.build-i NOTE            08048114 000114 000024 00   A  0   0  4
  [ 3] .rel.plt          REL             08048138 000138 000028 08   A  0   5  4
  [ 4] .init             PROGBITS        08048160 000160 000030 00  AX  0   0  4
  [ 5] .plt              PROGBITS        08048190 000190 000050 00  AX  0   0  4
  [ 6] .text             PROGBITS        080481e0 0001e0 065d5c 00  AX  0   0 16
  [ 7] __libc_freeres_fn PROGBITS        080adf40 065f40 000b57 00  AX  0   0 16
  [ 8] .fini             PROGBITS        080aea98 066a98 00001c 00  AX  0   0  4
  [ 9] .rodata           PROGBITS        080aeac0 066ac0 0191b0 00   A  0   0 32
  [10] __libc_subfreeres PROGBITS        080c7c70 07fc70 000030 00   A  0   0  4
  [11] __libc_atexit     PROGBITS        080c7ca0 07fca0 000004 00   A  0   0  4
  [12] .eh_frame         PROGBITS        080c7ca4 07fca4 0054d8 00   A  0   0  4
  [13] .gcc_except_table PROGBITS        080cd17c 08517c 00011a 00   A  0   0  1
  [14] .tdata            PROGBITS        080cef8c 085f8c 000010 00 WAT  0   0  4
  [15] .tbss             NOBITS          080cef9c 085f9c 000018 00 WAT  0   0  4
  [16] .ctors            PROGBITS        080cef9c 085f9c 00000c 00  WA  0   0  4
  [17] .dtors            PROGBITS        080cefa8 085fa8 00000c 00  WA  0   0  4
  [18] .jcr              PROGBITS        080cefb4 085fb4 000004 00  WA  0   0  4
  [19] .data.rel.ro      PROGBITS        080cefb8 085fb8 000030 00  WA  0   0  4
  [20] .got              PROGBITS        080cefe8 085fe8 00000c 04  WA  0   0  4
  [21] .got.plt          PROGBITS        080ceff4 085ff4 000020 04  WA  0   0  4
  [22] .data             PROGBITS        080cf020 086020 000740 00  WA  0   0 32
  [23] .bss              NOBITS          080cf760 086760 001b9c 00  WA  0   0 32
  [24] __libc_freeres_pt NOBITS          080d12fc 086760 000018 00  WA  0   0  4
  [25] .comment          PROGBITS        00000000 086760 00006c 01  MS  0   0  1
  [26] .shstrtab         STRTAB          00000000 0867cc 000110 00      0   0  1
  [27] .symtab           SYMTAB          00000000 086d64 0083e0 10     28 974  4
  [28] .strtab           STRTAB          00000000 08f144 00758a 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
                                                                                     |
ELF可执行文件中有一个专门的数据结构叫做程序头表(Program Header Table)用来保存"Segment"
的信息.                                                                              |
# readelf -l SectionMapping.elf
Elf file type is EXEC (Executable file)
Entry point 0x80481e0

There are 6 program headers, starting at offset 52
Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x000000 0x08048000 0x08048000 0x85296 0x85296 R E 0x1000
  LOAD           0x085f8c 0x080cef8c 0x080cef8c 0x007d4 0x02388 RW  0x1000
  NOTE           0x0000f4 0x080480f4 0x080480f4 0x00044 0x00044 R   0x4
  TLS            0x085f8c 0x080cef8c 0x080cef8c 0x00010 0x00028 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
  GNU_RELRO      0x085f8c 0x080cef8c 0x080cef8c 0x00074 0x00074 R   0x1
 Section to Segment mapping:
  Segment Sections...
   00     .note.ABI-tag .note.gnu.build-id .rel.plt .init .plt .text __libc_freeres_fn .fini .rodata __libc_subfreeres __libc_atexit .eh_frame .gcc_except_table
   01     .tdata .ctors .dtors .jcr .data.rel.ro .got .got.plt .data .bss __libc_freeres_ptrs
   02     .note.ABI-tag .note.gnu.build-id
   03     .tdata .tbss
   04    
   05     .tdata .ctors .dtors .jcr .data.rel.ro .got
                                                                                     |
Elf32_Phdr结构的几个成员与使用readelf -l 命令打印文件头表显示的结果一一对应.         |
/usr/src/linux/include/linux/elf.h
typedef struct elf32_phdr
{
    Elf32_Word p_type;
    Elf32_Off p_offset;
    Elf32_Addr p_vaddr;
    Elf32_Addr p_paddr;
    Elf32_Word p_filesz;
    Elf32_Word p_memsz;
    Elf32_Word p_flags;
    Elf32_Word p_align;
} Elf32_Phdr;

Elf32_Phdr->p_type                                                                   |
段的类型, 它能告诉我们这个段里存放着什么用途的数据. 此字段的值是在elf.h中定义了一些常|
量. 例如1(PT_LOAD)表示是可加载的段, 这样的段将被读入程序的进程空间成为内存映像的一部 |
分. 段的种类再不断增加, 例如7(PT_TLS)在以前就没有定义, 它表示用于线程局部存储.       |
Elf32_Phdr->p_flags                                                                  |
段的属性. 它用每一个二进制位表示一种属, 相应位为1表示含有相应的属性, 为0表示不含那种 |
属性. 其中最低位是可执行位, 次低位是可写位, 第三低位是可读位. 如果这个字段的最低三位 |
同时为1那就表示这个段中的数据加载以后既可读也可写而且可执行的. 同样在elf.h文件中也定 |
义了一此常量(PF_X PF_W PF_R)来测试这个字段的属性, 做为一个好习惯应该尽量使用这此常量.|
Elf32_Phdr->p_offset                                                                 |
该段在文件中的偏移. 这个偏移是相对于整个文件的.                                      |
Elf32_Phdr->p_vaddr                                                                  |
该段加载后在进程空间中占用的内存起始地址.                                            |
Elf32_Phdr->p_paddr                                                                  |
该段的物理地地址. 这个字段被忽略, 因为在多数现代操作系统下物理地址是进程无法触及的.  |
Elf32_Phdr->p_filesz                                                                 |
该段在文件中占用的字节大小. 有些段可能在文件中不存在但却占用一定的内存空间, 此时这个 |
字段为0.                                                                             |
Elf32_Phdr->p_memsz                                                                  |
该段在内存中占用的字节大小. 有些段可能仅存在于文件中而不被加载到内存,此时这个字段为0.|
Elf32_Phdr->p_align                                                                  |
对齐. 现代操作系统都使用虚拟内存为进程序提供更大的空间, 分页技术功不可没, 页就成了最 |
小的内存分配单位, 不足一页的按一页算. 所以加载程序数据一般也从一页的起始地址开始, 这 |
就属于对齐.                                                                          |
                                                                                     |
在Linux下, 我们可以通过查看"/proc"来查看进程的虚拟空间分布.                          |
# ./SectionMapping.elf  &
[1] 2458
# cat  /proc/2458/maps
00da3000-00da4000 r-xp 00000000 00:00 0          [vdso]
08048000-080ce000 r-xp 00000000 08:01 209272     /xxx/SectionMapping.elf
080ce000-080d0000 rw-p 00085000 08:01 209272     /xxx/SectionMapping.elf
080d0000-080d2000 rw-p 00000000 00:00 0
08bb6000-08bd8000 rw-p 00000000 00:00 0          [heap]
bfc81000-bfca2000 rw-p 00000000 00:00 0          [stack]
                                                                                     |
第一列表示VMA的地址范围; 第二列是VMA的权限, rwx, "p"表示(COW), "s"表示共享, 第三列表 |
示偏移, 表示VMA对应的Segment在映像文件中的偏移, 第四列表示映像文件所在设备的主次设备 |
号, 第五列表示文件的节点号. 最后一列表示映像文件的路径.                              |
vdso的地址位于内核空间, 他是一个内核模块, 进程可以通过访问这个VMA来跟内核通信. 主设备|
号和此设备号都为0的段叫做匿名虚拟内存区域(Anonymous Virtual Memory Area).            |
操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间; 基本原则是将相同权限属性的|
, 有相同映像文件的映射成一个VMA.                                                     |
一个进程可以分为如下几种VMA区域:                                                     |
*代码VMA rx, 有映像文件
*数据VMA rwx, 有映像文件
*堆VMA rwx, 无映像文件,匿名,可向上扩展
*栈VMA rx, 无映像文件,匿名,可向下扩展
                                                                                     |
----> ELF文件的装载过程                                                              |
fork->execve()->sys_execve()->do_execve()                                            |
do_execve()读取文件的前128个字节判断文件的格式(一般根据魔数来判断, 比如elf的头四个字 |
节为: 0x7F, e, l, f). 然后调用search_binary_handle()去搜索和匹配合适的可执行文件装载 |
处理过程, 对于elf则调用load_elf_binary():                                            |
*检查ELF可执行文件格式的有效性                                                       |
*寻找动态链接的".interp"段, 设置动态连接器路径                                       |
*根据ELF可执行文件的程序头表的描述, 对ELF文件进行映射, 比如代码 数据 只读数据.       |
*根据ELF进程环境, 比如进程启动是EDX寄存器的地址应该是DT_FINI的地址.                  |
*将系统调用的返回地址修改成ELF可执行文件的入口点, 这个入口点取决于程序的链接方式, 静 |
 态ELF可执行文件为e_entry所指的地址, 对于动态ELF入口点为动态连接器.                  |
Load_elf_binary()执行完毕, 返回至do_execve()再返回至sys_execve(), 最后一步的系统调用 |
返回地址改成了被装在的ELF程序入口地址. 当sys_execve()系统调用从内核态返回到用户态时, |
EIP寄存器直接跳转到了ELF程序的入口地址, 新程序开始执行.                              |
Windows PE文件的装载 略.                                                             |
-------------------------------------------------------------------------------------|
http://www.cnblogs.com/zhuyp1015/archive/2012/05/06/2486706.html                     |
----> 动态链接                                                                       |
静态链接浪费内存和磁盘空间, 模块更新困难等问题, 因此寻找一种更好的办法来组织程序模块.|
静态链接对程序的更新, 部署和发布也会带来很多麻烦.                                    |
动态链接: 就是不对那些组成程序的目标文件进行链接, 等到程序要运行时才进行链接. 动态链 |
接的方式使得开发过程中各个模块更加独立, 耦合度更小, 便于不同的开发者和开发组织之间进 |
行独立的开发和测试. 动态链接还有一个特点就是程序在运行时可以动态的选择加载各种程序模 |
块, 使得插件成为可能. Linux系统中, ELF动态链接文件被称为动态共享对象(DSO, Dynamic    |
Shared Objects), 简称共享对象, 它们一般都是以".so"为扩展名; 动态链接文件被称为动态链 |
接库. 在windows下为.dll.                                                             |




-------------------------------------------------------------------------------------|
3 安装使用Cscope                                                                     |
Cscope提供交互式查询语言符号功能,如查询哪些地方使用某个变量或调用某个函数. Cscope已经|
是Vim的标准特性, 默认都有支持, 官方网址为http://cscope.sourceforge.net/.             |
a) 在Vim下运行version查看Vim支持哪些特性, 前面有前缀符号+的为支持. 如果支持Cscope,则 |
   直接进入b), 否则下载Cscope源代码包编译安装. 步骤同Ctags安装.                      |
b) 确定Vim已支持Cscope后, 将文件http://cscope.sourceforge.net/cscope_maps.vim下载到  |
   ~/.vim/plugin目录. 到这里, 我们就可以开始使用Cscope了.                            |
c) 使用Cscope需要生成cscope数据库文件。进入项目代码根目录运行命令：                  |
       cscope -Rbq -f path/xxx.out                                                   |
   命令运行后会生成xxx.out文件,即cscope数据库文件. 更多用法参考man cscope文档。      |
d) 进入项目代码根目录, 在Vim下运行命令：                                             |
   :cs add /home/wooin/vim71/cscope.out /home/wooin/vim71                            |
   此命令将cscope数据库载入Vim. 上面这条命令很重要, 必须写全, 不能只写前半句. 因为源 |
   码是多级目录的, 如果这样写, cscope是无法在子目录中的源码中工作的, 当然, 如果你的源|
   码都在同一级目录中就无所谓了. 如果你要经常用cscope的话, 可以把上面那句加到~/.vimrc|
   中去.                                                                             |
e) Cscope常用快捷键                                                                  |
一些快捷键的用法, 下面是其中一组, 也是我用的, 将下面的内容添加到~/.vimrc中,并重启vim:|
nmap <C-_>s :cs find s <C-R>=expand("<cword>")<CR><CR>
nmap <C-_>g :cs find g <C-R>=expand("<cword>")<CR><CR>
nmap <C-_>c :cs find c <C-R>=expand("<cword>")<CR><CR>
nmap <C-_>t :cs find t <C-R>=expand("<cword>")<CR><CR>
nmap <C-_>e :cs find e <C-R>=expand("<cword>")<CR><CR>
nmap <C-_>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
nmap <C-_>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
nmap <C-_>d :cs find d <C-R>=expand("<cword>")<CR><CR>                               |
当光标停在某个你要查找的词上时, 按下<C-_>g, 就是查找该对象的定义, 其他的同理. 按这种 |
组合键有一点技巧, 按了<C-_>后要马上按下一个键, 否则屏幕一闪就回到nomal状态了. <C-_>g |
的按法是先按"Ctrl+Shift+-", 然后很快再按"g"                                          |
为了界面更好看, 可以把Cscope的查找结果输出到quickfix窗口, 需要在~/.vimrc中加入下面这 |
行:                                                                                  |
:set cscopequickfix=s-,c-,d-,i-,t-,e-                                                |
这样, 通过快捷键查找某个符号后, 会立即跳转到第一个找到的该符号出现的位置. 如果你对这 |
次默认跳转的位置不满意, 在Vim命令行下运行cw命令,                                     |
:cw                                                                                  |
就能在编辑区下面quickfix窗口看到所有, 查找结果的列表, 点击相应列表项就能跳转到相应位 |
置.                                                                                  |


------>
http://blog.csdn.net/larntin2002/article/details/1821430
-------------------------------------------------------------------------------------|
libtool常见于autoconf/automake, 单独用的例子很少, 所以我想仔细研究一下, 为将来兄弟们 |
看起来方便.                                                                          |
一 libtool的作用                                                                     |
offer a standard procedure for creating shared libraries on different platforms.     |
libtool是一个通用库支持脚本, 将使用动态库的复杂性隐藏在统一可移植的接口中, 也就是说, |
你可以通过如下所示的标准方法, 在不同平台上创建并调用动态库, 我们可以认为libtool是gcc |
的一个抽象, 也就是说, 它包装了gcc或者其他的任何编译器, 用户无需知道细节, 只要告诉    |
libtool说我需要要编译哪些库即可, 并且它只与libtool文件打交道, 例如lo la为后缀的文件. |
二 libtool的使用                                                                     |
1. Creating object files
#libtool --mode=compile gcc -g -O -c foo.c
 gcc -g -O -c foo.c  -fPIC -DPIC -o .libs/foo.o
 gcc -g -O -c foo.c -o foo.o >/dev/null 2>&1
# libtool --mode=compile gcc -g -O -c hello.c
 gcc -g -O -c hello.c  -fPIC -DPIC -o .libs/hello.o
 gcc -g -O -c hello.c -o hello.o >/dev/null 2>&1                                     |
说明:libtool编译出两个版本的relocatable object, 一个是fPIC(位置无关的), 放在.libs目录|
下; 另一个则是普通的, 放在本地.                                                      | 
2. linking shared library
# libtool --mode=link --tag=CC gcc -g -O -o libhello.la -rpath /usr/local/lib foo.lo
 rm -fr  .libs/libhello.a .libs/libhello.la .libs/libhello.lai .libs/libhello.so libs/libhello.so.0 .libs/libhello.so.0.0.0
 gcc -shared  .libs/foo.o   -Wl,-soname -Wl,libhello.so.0 -o .libs/libhello.so.0.0.0
 (cd .libs && rm -f libhello.so.0 && ln -s libhello.so.0.0.0 libhello.so.0)
 (cd .libs && rm -f libhello.so && ln -s libhello.so.0.0.0 libhello.so)
 ar cru .libs/libhello.a  foo.o
 ranlib .libs/libhello.a
 creating libhello.la
 (cd .libs && rm -f libhello.la && ln -s ../libhello.la libhello.la)                 |
说明:link出两个共享库, 一个是static, 一个则是dynamic; 需要注意的是, -rpath必须有才能 |
产生dynamic库来, 如果用-static, 则只创建static库.                                    |
 
ranlib的作用：
On some older UNIX systems, ranlib added a table of contents to archive libraries, which converted each archive to a form that could be linked more rapidly. This is no longer needed as the ar command automatically provides all the functionality ranlib used to provide.
在一些旧版本的系统上，ranlib负责把静态库转换为其他的某种格式，使得新的库能够更快的链接；现在ar命令已经包含了上述功能；
This command is provided as a convenience for software developers who need to maintain Makefiles that are portable across a variety of operating systems.
为了兼容性，在makefile中还是保留ranlib
 
3.install shared library
libtool --mode=install cp libhello.la /usr/local/lib/libhello.la
libtool --mode=install install -c libhello.la /usr/local/lib/libhello.la
两个命令都可以，效果相同
 
4.linking executable file
# libtool --mode=link gcc -g -O -o hello hello.lo -rpath /usr/local/lib libhello.la
 gcc -g -O -o .libs/hello .libs/hello.o  ./.libs/libhello.so
 creating hello
 -rpath项负责添加运行时库路径，否则只能手工修改LD_LIBRARY_PATH环境变量了。
 验证一下：
# ldd .libs/hello
        linux-gate.so.1 =>  (0xffffe000)
        libhello.so.0 => /usr/local/lib/libhello.so.0 (0x40019000)
        libc.so.6 => /lib/tls/libc.so.6 (0x40031000)
        /lib/ld-linux.so.2 (0x40000000)
 
5.install executable file       
#libtool --mode=install cp hello /usr/local/bin/hello
安装可执行程序。
 
6.运行
libtool --mode=execute hello
或直接运行hello
注意：此处hello已经安装在/usr/local/bin下了，可以用which hello来查看
 
【附】源码
foo.c
#include <stdio.h>
char msg[128]="Hello world";
void print()
{
        printf("%s/n", msg);
}
 
hello.c:
#include <stdio.h>
extern char msg[128];
extern void print();
int main()
{
        print();
}
 
Makefile:
LO_OBJS = foo.lo
PACKAGE_VERSION = 1:1:1
LIBDIR=/usr/local/lib
BINDIR=/usr/local/bin
 
all : hello
 
install : libhello.la hello
  libtool --mode=install install -c libhello.la
 
${LIBDIR}/libhello.la
  libtool --mode=install cp hello ${BINDIR}/hello
 
uninstall : ${LIBDIR}/libhello.la ${BINDIR}/hello
  libtool --mode=uninstall /bin/rm ${LIBDIR}/libhello.la
  libtool --mode=uninstall /bin/rm ${BINDIR}/hello
 
hello : libhello.la hello.o
  libtool --mode=install install -c libhello.la
 
${LIBDIR}/libhello.la
  libtool --mode=link gcc -g -O -o hello hello.o -rpath ${LIBDIR} libhello.la
 
libhello.la : $(LO_OBJS)
   libtool  --mode=link --tag=CC gcc -g -O -o libhello.la
 
$(LO_OBJS) -rpath ${LIBDIR} ${PACKAGE_VERSION}
 
foo.lo : foo.c
   libtool --mode=compile gcc -g -O -c foo.c
 
hello.lo : hello.c
   libtool --mode=compile gcc -g -O -c hello.c
 
clean :
  rm -f lib*.a *~ *core *.lo *.o *.la hello
  rm -rf .libs
 
这样，用户可以用make编译，make install/uninstall安装/卸载，make clean清除编译临时文件，安装成功后，可以直接执行hello，不必指明路径也不必再另设环境变量LD_LIBRARY_PATH，非常方便！
